<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Julia Posts on Stamatis Vretinaris</title><link>https://svretina.github.io/julia/</link><description>Recent content in Julia Posts on Stamatis Vretinaris</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 01 Jan 2024 20:03:59 +0200</lastBuildDate><atom:link href="https://svretina.github.io/julia/index.xml" rel="self" type="application/rss+xml"/><item><title>Packages in Julia</title><link>https://svretina.github.io/julia/packages/</link><pubDate>Sat, 25 May 2024 18:51:48 -0400</pubDate><guid>https://svretina.github.io/julia/packages/</guid><description>Packages in Julia When experimenting and writing new code a package structure seems to be an overkill, but as a project matures the package structure provides some advantages (imho).
First let us look how a package MyPackage looks like in Julia
&amp;gt; ls MyPackage .git .github/workflows docs src test .gitignore LICENSE Project.toml Manifest.toml README.md /src ls /src MyPackage.jl its the folder where your code will live. In a newly initiallized package there will be always the file MyPackage.</description></item><item><title>Introduction to SIMD in Julia</title><link>https://svretina.github.io/julia/simd/</link><pubDate>Mon, 01 Jan 2024 19:59:56 +0200</pubDate><guid>https://svretina.github.io/julia/simd/</guid><description>SIMD instructions in Julia SIMD stands for “single instruction, multiple data” and is a class of parallel computers in Flynn&amp;rsquo;s taxonomy. It describes computers with multiple processing elements that perform the same operation on multiple data points simultaneously.
In order to take advantage of the modern CPU&amp;rsquo;s potential it is essential to utilize SIMD instructions. Lets check if our CPU supports these features. On a UNIX machine
lscpu | grep avx lscpu | grep sse function func return 0 end</description></item></channel></rss>